# 顺序表

## 分类

从大的概念上说，顺序表主要是分成两大类，一类是连续空间的线性表，另一类不连续空间的链表。

两类顺序表，各有各的优点和缺点。

## 连续空间顺序表

### 代码

```golang
package main

import "fmt"

type DynamicArray struct {
	T []int // 当前数组的地址
	L int   // 当前数组长度
	C int   // 当前数组的容量
	d int   // 数组增加的速度
}

// NewDynamicArray 生成动态线性表
func NewDynamicArray() *DynamicArray {
	d := 10
	return &DynamicArray{
		L: 0,
		C: d,
		d: d,
		T: make([]int, d),
	}
}

// increase
func (d *DynamicArray) increase() {
	T := d.T
	d.C = d.C + d.d
	d.T = make([]int, d.C)
	copy(d.T, T)
}

// Push 添加一个新元素，返回当前数组长度
func (d *DynamicArray) Push(e int) int {
	if d.L >= d.C {
		// 重新分配空间
		d.increase()
	}
	d.T[d.L] = e
	d.L++
	return d.L
}

// Get 得到特定位置的元素值
func (d *DynamicArray) Get(idx int) int {
	if idx < 0 || idx >= d.L {
		panic(fmt.Sprintln("访问越界", "\n===>当前数组长度：", d.L, "\n===>当前访问的位置：", idx))
		// 抛出异常
		// 为什么不抛出错误，因为，get本身更希望能够使用链式法则
		// 此处，抛出异常是一种小概率的事件，因为函数本身只是受到逻辑限制，而不受具体的硬件限制
	}
	return d.T[idx]
}

// Remove 删除指定位置的元素
func (d *DynamicArray) Remove(idx int) int {
	r := d.Get(idx)
	for i := idx + 1; i < d.L; i++ {
		d.T[i-1] = d.T[i]
	}
	d.L--
	return r
}

// Pop 删除最后位置的元素
func (d *DynamicArray) Pop() int {
	r := d.Get(d.L - 1)
	d.L--
	return r
}

// Insert 在指定位置插入元素
func (d *DynamicArray) Insert(idx int, e int) int {
	d.Push(e)
	d.Get(idx) // 检查 idx 的有效性
	for i := d.L - 1; i > idx; i-- {
		d.T[i] = d.T[i-1]
	}
	d.T[idx] = e
	return d.L
}

// Replace 在指定位置替换元素，返回替换前的值
func (d *DynamicArray) Replace(idx int, e int) int {
	r := d.Get(idx)
	d.T[idx] = e
	return r
}

func (d *DynamicArray) String() string {
	rst := ""
	for i := 0; i < d.L; i++ {
		rst += fmt.Sprintf("%d ", d.T[i])
	}
	return rst
}

func main() {
	A := NewDynamicArray()
	A.Push(1)
	A.Push(2)
	A.Push(3)
	A.Push(4)
	A.Push(5)
	A.Push(6)
	A.Push(7)
	A.Push(8)
	A.Push(9)
	A.Push(10)
	fmt.Println("初始化序列：")
	fmt.Println(A)
	fmt.Println("在第二个位置，插入13")
	A.Insert(1, 13)
	fmt.Println(A)
	fmt.Println("在第二个位置，插入14")
	A.Insert(1, 14)
	fmt.Println(A)
	fmt.Println("弹出最后一个元素")
	A.Pop()
	fmt.Println(A)
	fmt.Println("移除第二个元素")
	A.Remove(1)
	fmt.Println(A)
	fmt.Println("替换第一个元素，值15")
	A.Replace(0, 15)
	fmt.Println(A)
}
```

## 栈

## 链表

## 队列
