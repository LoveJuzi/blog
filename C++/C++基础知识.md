# C++ 基础知识

首先，不要着急让自己明白所有的概念，这些都是需要时间的，你要做的是尽可能在单位时间内消化更多的知识点。

C++你是有语言基础的，消化的时候注意回想总结，明白一些基本的概念，重要的是，心态保持平衡，这点对于现在是极难做到的。

采用分治法的思路解决这个问题。

1. C++的基本语法
2. C++的面向对象基本概念
3. C++的多态实现原理
4. C++的内存管理
5. C++的标准库的基本组成
6. C++实现一个简单的String类

## C++的基本语法

还是采用分治法的策略

1. 基本的数据类型
2. 基本的控制结构
3. 类的定义
4. 类的构造函数，析构函数，拷贝构造函数，复制构造函数的概念
5. 类的封装
6. 类的继承
7. 类的多态

### 基本数据类型

基本的数据类型如下：

    bool, char, int, float, double, void, wchar_t

基本的类型修饰符如下：

    signed, unsigned, short, long

变量作用域

    1. 局部变量
    2. 全局变量
    3. 形式参数

    这里特别的说明一下“形式参数”，函数参数中定义的变量都是“形式参数”，通常形式参数都是值拷贝，C++引入一个引用拷贝，引用拷贝使得形式参数可以变成“值-结构”参数，有点类似指针的作用，但是，不同与指针的是，指针的“形式参数”也是值拷贝。

为了理解作用域的概念，这里需要简单的说下，C++的内存分配基本知识：

    1. 栈区---有编译器自动分配释放，局部变量，形式化参数等值的存储区域
    2. 堆去---一般由程序员分配释放，主要使用new或者malloc，realloc等进行内存申请，如果程序员不释放，会在程序结束的时候，由OS回收
    3. 全局区（静态区）--- 全局变量和静态变量存放的地方，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后，有系统回收
    4. 文字常量区 --- 常量和常量字符串就是放在这里。程序结束后由系统释放
    5. 程序代码区 --- 存放函数体的二进制代码

~~new, malloc, realloc 的区别~~

~~内存泄漏是个什么概念？~~

特殊的作用域

    C语言有个很特别的关键字“static”，这个关键字可以修饰变量类型，使得变量变成一个静态变量，这个修饰符还可以修饰函数，使得函数变成静态函数，某种意义上函数也是一个变量，嗯，这么说函数更像一个指针值，函数名就是可以表示这个函数的指针值。

    所谓的静态类型，可以理解成一个环境变量，全局变量其实可以理解成全局的环境变量。

    静态的局部变量就相当于局部的环境变量，理论上来说，局部变量是存在在堆栈中，随着局部状态的退出而消失，静态的局部变量不同，静态局部变量是存放在全局静态区，是不会随局部状态的退出而回收的。

    静态变量还有一个很重要的特性，限定了变量的作用范围，静态的局部变量先定了变量的范围为局部变量的使用范围，静态的全局变量，限定了变量自当前声明处起至文件末尾有效，不可被extern执行外部引用。

    静态成员函数也有此特性，静态成员函数是属于类的属性，不是对象的属性。同理，还有静态成员变量，静态成员变量也是类的属性，不是对象的属性。所谓的类的属性，就是说所有对象共享这个属性。

const修饰符

    const修饰一个变量的时候，这个变量我们称之为常量变量，这是const的一种简单用法。

    其实，const是限定某个变的东西使得不可变，具体的有如下一些用法：
    
        1. 限定变量，使得变量变成常量
        2. 限定引用类型的形式参数，使得引用类型的形式参数不可修改
        3. 限定成员函数，使得成员函数中不能修改对象的成员变量

const 和 指针 的复合修饰

    指针变量这里以 "int * a" 做为例子进行解释。

    指针变量有两个特性，一个特性是修改指针本身的值，一个是修改指针所指向地址的值。

    基于指针的特性，const对指针类型的变量，也有两种修饰方式：

        1. const int * a; // 此种情况，说明指针所指向的地址的值不可修改
        2. int const * a; // 此种情况和1相同，只是语法问题
        3. int * const a; // 此种情况，说明指针本身的值不可修改
        4. const int * const a; // 此种情况，说明指针的和指针所指向的地址值都是不可修改的

### 基本的控制语句

嗯，C++的控制语句和C语言的基本是一致的，也就是 if...else... while... for... 之类的

### 类的定义

类从整体上来说，C++类的主要分成三个部分：类名，成员函数，成员变量

C++为了保证封装性对成员函数和成员变量使用了修饰符：public，protected，private

C++的继承也有这三个特殊的修饰符，这里，我们需要对这三个特殊的修饰符进行简要的说明

第一：private, public, protected 访问标号的访问范围。

private：只能由1.该类中的函数、2.其友元函数访问。
不能被任何其他访问，该类的对象也不能访问。

protected：可以被1.该类中的函数、2.子类的函数、以及3.其友元函数访问。
但不能被该类的对象访问。

public：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问，也可以由4.该类的对象访问。

注：友元函数包括3种：设为友元的普通的非成员函数；设为友元的其他类的成员函数；设为友元类中的所有成员函数。

第二：类的继承后方法属性变化。
private 属性不能够被继承。
使用private继承，父类的protected和public属性在子类中变为private;
使用protected继承，父类的protected和public属性在子类中变为protected;
使用public继承，父类中的protected和public属性不发生改变;

如下所示：
                    public          protected:      private:
public继承          public          protected       不可用
protected继承       protected       protected       不可用
private继承         private         private         不可用

protected继承和private继承能降低访问权限。

这里，首先这里只是说子类不能直接访问父类的私有成员，并不是说，子类不能使用父类的私有成员，其实父类的私有成员还是被创建的。

构造函数的初始化列表的使用注意事项:

    1、成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了。这点在EffectiveC++中有详细介绍。
    2、如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。
    3、注意：类成员在定义时，是不能初始化的
    4、注意：类中const成员常量必须在构造函数初始化列表中初始化。
    5、注意：类中static成员变量，必须在类外初始化。
    6、静态变量进行初始化顺序是基类的静态变量先初始化，然后是它的派生类。直到所有的静态变量都被初始化。这里需要注意全局变量和静态变量的初始化是不分次序的。这也不难理解，其实静态变量和全局变量都被放在公共内存区。可以把静态变量理解为带有“作用域”的全局变量。在一切初始化工作结束后，main函数会被调用，如果某个类的构造函数被执行，那么首先基类的成员变量会被初始化。  

类的继承构造函数的调用顺序

    记忆原则，从“根”出发，一层一层到要构造的类；
    析构函数则恰好相反
    C++构造函数按下列顺序被调用：
    (1)任何虚拟基类的构造函数按照它们被继承的顺序构造；
    (2)任何非虚拟基类的构造函数按照它们被继承的顺序构造；
    (3)任何成员对象的构造函数按照它们声明的顺序调用； // 很重要，这点也很好理解，程序就是按照顺序去进行内存填充的
    (4)类自己的构造函数。

C++中的虚拟继承

    主要是针对如下情况：
          A 
        /   \ 
        B    C 
        \   / 
          D 
    类D在实例化的时候，存储区只会有一个类A，不会存在二义性，其中类B，类C都是虚拟继承类A，类A被称为虚拟基类

友元概念

    嗯，友元本身从设计上来说是破坏C++类的封装特性，一个类的友元函数/友元类具有和该类类似的性质，可以访问该类的私有成员

友元的分类

    1. 友元函数
    2. 友元类

友元函数

    这里需要重点说明一下，C++中的函数其实本质上就一种，但是，在形式上是分成两大类，一类是传统C语言的全局函数和静态全局函数，另一类是类对象中的成员函数和静态成员函数。

    不论是哪一种特性的函数，他们都是有一个函数指针。

    这里还要注意一点，对于类的私有成员函数，这里是不能够进行访问的，主要的原因：

        1. 首先函数的指针在声明友元的时候需要有地址，对于私有成员函数来说，它的地址是不对外开放的
        2. 即便使用循环引用的情况，也必须保证其中的一个类需要定义完成，否则也是无法取得函数地址的

    嗯，这里其实涉及的一个重要点，就是函数指针的获取。 // 这里的描述貌似有问题，这里还需要进一步的探讨一下

    通常而言，我们会对比较运算符的重载函数实现友元形式，因为理论上来说，比较运算符通常是在两个相同类型的不同对象上进行的，他们理论上应该是属于平级关系，没有谁包含谁这个概念。

    当然使用“A.Compare(B)”这种形式也是可以，不过“A > B” 这种形式更美观一点。

友元类

    两个关系比较近的类，比如一个司机可以有用一辆车，司机类就可以是车类的一个友元类，司机可以方位车的私有属性。

### 类的构造函数，析构函数，拷贝构造函数，复制构造函数的概念

首先明白构造函数的意义：程序代码一般都会经历两个阶段，第一个阶段初始化阶段，这一阶段可以理解成世界的开始状态，第二个阶段运转阶段，这一阶段就是整个世界在开始状态的情况下开始运转。

对于第一阶段其实是程序员比较容易忽视的，因为大家大部分的精力都是放在第二阶段世界应该如何运转，更专业的术语是我们更多关注的是算法的实现。

C++为了更好的提醒程序员，每个世界都应该有个初始化的过程，所以，使用了构造函数这个概念，用来显示的控制世界的初始化的过程。

C++存在四大构造函数：

    1. 默认构造函数（无参构造函数）
    2. 有参构造函数
    3. 拷贝构造函数
    4. 赋值构造函数

当类没有定义构造函数的时候，C++会为类生成一个默认构造函数，默认构造函数是无参形式的，默认构造函数会根据成员变量的数据类型设置默认的初始化值，如果用户主动定义无参构造函数，那么默认构造函数的行为将会被隐藏。

有参构造函数主要是应对某些类实例化对象的时候需要引入一些配置参数，这时候，有参构造函数就能将这些配置参数设置成形式化参数。

拷贝构造函数主要应对如何从另一个同类型的对象拷贝一份新的对象，这里需要注意一点，C++的拷贝分深拷贝和浅拷贝两种，这两种都有对应的用法。

    拷贝构造函数必须以引用的方式传递参数。这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。

赋值构造函数功能和拷贝构造函数类似，但是这里有着本质的区别：

    1. 赋值构造函数其实是运算符重载，重载的是赋值运算符
    2. 赋值构造函数应该不能叫构造函数，理论上构造函数是要支持初始化列表这种形式的，赋值构造函数只能在函数体中对类的成员进行初始化
    3. 为了满足赋值的连续性，赋值构造函数通常需要返回类对象的自引用
    4. 如果一个对象没有构造过，那么及时在定义的时候使用赋值运算符，其实本质编译器会调用拷贝构造函数，这也说明，赋值构造函数只是针对已经构造过的对象才会起作用

为了更好的理解这段内容，这里引入一个String类的简单实现：

    ```c++
    #include <string.h>

    using namespace std;

    class String {
    public:
        String();
        String(char * sch);
        String(const String & oth);
        String & operator = (const String & oth);
        ~String();

        void SetString(char * sch);

    private:
        void NewString(int size);
        void ReleaseString();

    private:
        char * m_ch; // 存储实际的字符串
        int m_len;   // 存储当前字符串的长度，此长度不含有'\0'
    };

    String::String() : m_len(-1), m_ch(nullptr) {
    }

    String::String(char *sch) : m_len(-1), m_ch(nullptr) {
        this->SetString(sch);
    }

    String::String(const String & oth) : m_len(-1), m_ch(nullptr) {
        this->SetString(oth.m_ch);
    }

    String & String::operator=(const String &oth) {
        if (this == &oth) {
            return *this;
        }
        this->SetString(oth.m_ch);
        return *this;
    }

    String::~String() {
        this->ReleaseString();
    }

    // 引入一个字符串
    void String::SetString(char * sch) {
        this->ReleaseString();
        if (this->sch != nullptr) {
            this->NewString(strlen(sch));
            strcpy(this->m_ch, sch);
        }
    }

    // 引入辅助函数，创建一片字符串存储空间
    void NewString(int size) {
        this->m_len = size;
        this->m_ch = new char[size+1];
        this->m_ch[size] = '\0';
    }

    // 引入辅助函数，释放原有的内存
    void String::ReleaseString() {
        if (this->m_ch != nullptr) {
            delete [] this->m_ch;
            this->m_ch = nullptr;
        }

        this->m_len = -1;
    }
    ```

这段代码其实蛮困难的，考虑的点其实比较多，嗯，这段代码要是能够在任何时段手写出来，对C++的基本知识点其实都考量的差不多了。

~~构造函数中的this指针~~

~~深拷贝和浅拷贝的理解~~

智能指针（这里使用了一个浅拷贝的概念）

    智能指针的作用是为了降低程序员对C++指针的管理工作，嗯，智能指针的实现在C++中也是比较容易理解的，采用一个包装类，用这个包装类来管理指针的生命周期。

    包装类采用普通的栈对象，栈对象的管理是由栈内存管理的，所以无需程序员手段清理。

    另外，包装类需要实现指针的一些运算符操作，比如“*”和“->”，还是赋值运算符等等。

智能指针的实现

    ```c++
    // 要求 T 是指针类型，不能是数组类型的指针
    template <class T>
    class SmartPointer {
    private:
        T * _ptr; // 需要被包装的指针
        int * _count; // 智能指针的引用计数

    public:
        SmartPointer(T * ptr = nullptr);
        SmartPointer(const SmartPointer & oth);
        ~SmartPointer();

        SmartPointer<T> & operator=(const SmartPointer & oth);

        T & operator*();

        T * operator->();

    private:
        // 辅助函数，用来释放引用计数
        void release();
    };

    template <class T>
    SmartPointer<T>::SmartPointer(T * ptr) : _ptr(ptr), _count(nullptr) {
        if (_ptr != nullptr) {
            _count = new int(1);
        }
    }

    template <class T>
    SmartPointer<T>::SmartPointer(const SmartPointer & oth) : _ptr(nullptr), _count(nullptr) {
        if (oth._ptr != nullptr) {
            _ptr = oth._ptr;
            _count = oth._count;
            (*_count)++; // 引用计数+1
        }
    }

    template <class T>
    SmartPointer<T> & SmartPointer<T>::operator = (const SmartPointer & oth) {
        if (this == &oth) {
            return *this;
        }

        release();

        if (oth._ptr != nullptr) {
            _ptr = oth._ptr;
            _count = oth._count;
            (*_count)++; // 引用计数+1
        }

        return *this;
    }

    template <class T>
    SmartPointer<T>::~SmartPointer() {
        release();
    }

    template <class T>
    void SmartPointer<T>::release() {
        if (_count == nullptr) {
            return;
        }
        (*_count)--; // 引用计数-1
        if (*_count == 0) {
            delete _ptr;
            _ptr = nullptr;
            delete _count;
            _count = nullptr;
        }
    }

    template <class T>
    T & SmartPointer<T>::operator *() {
        assert(this->_ptr != nullptr);
        return *(this->_ptr);
    }

    template <class T>
    T * SmartPointer<T>::operator -> () {
        assert(this->ptr != nullptr);
        return this->_ptr;
    }
    ```

右值

    右值引用实现了在多种场景下消除了不必要的开销，这句话有点难懂，是怎么消除的呢？

    右值是C++从C继承的概念，最初是指等号右边的值，不过C++的更改了这个定义，C++中的右值指的是临时值或常量，更准确的说，保存在CPU寄存器中的值为右值（这里持怀疑的态度），而保存在内存中的值为左值。

    嗯，更简单的一种判定方式是，如果一个值可以取地址操作，那么他就是左值，否则就是右值。

右值引用

    在C++中我们对左值都有一个左值引用，对于右值，C++ 11也有一个右值引用。

    所谓的右值引用和左值引用一样，在定义的时候就需要初始化，嗯，对于形式化参数也是和左值引用类似。

    不同的是，右值引用只能引用右值类型的数据，不能引用左值类型的数据，左值引用只能引用左值类型的数据，不能引用右值类型的数据。

    嗯，这里还有个问题，对于右值引用能否使用一个右值引用类型的数据呢？

    这种问题，可以这么来想，我们知道在左值引用的情况下，上述的结论是对的，左值引用可以使用一个左值引用类型的数据，所以，反之，右值引用类型是不能引用右值引用类型的数据，因为引用类型本身是左值类型的。

通用引用

    所谓的通用引用，就是既可以引用左值类型的值又可以引用右值类型的引用。

    通用引用有两种定义方式：

        一种是auto，也就是 auto && ，但是 const auto && 这个不是通用引用
        另一种是通过模板定义的T&&

构造函数的选择问题

    1. C++是支持函数重载的，所谓的函数重载是说，函数的形式参数可以不同
    2. C++的函数重载是如何进行调用的？这里有个基本的原则，那个更像就调用哪个，换句话说，那个类型更接近我们就调用哪个函数

移动构造函数

~~函数对象~~

## STL

~~emplace_back()~~

lower_bound, upper_bound

    lower_bound算法返回一个非递减序列[first, last)中第一个大于等于值val的位置
    upper_bound算法返回一个非递减序列[first, last)中第一个大于val的位置

lower_bound的实现

    ```c++
    int lower_bound(int *array, int size, int key)
    {
        int first = 0, middle;
        int half, len;
        len = size;

        while(len > 0) {
            half = len >> 1;
            middle = first + half;
            if(array[middle] < key) {     
                first = middle + 1;          
                len = len-half-1;       //在右边子序列中查找
            }
            else
                len = half;            //在左边子序列（包含middle）中查找
        }
        return first;
    }
    ```

upper_bound的实现

    ```c++
    int upper_bound(int *array, int size, int key)
    {
        int first = 0, len = size-1;
        int half, middle;

        while(len > 0){
            half = len >> 1;
            middle = first + half;
            if(array[middle] > key)     //中位数大于key,在包含last的左半边序列中查找。
                len = half;
            else{
                first = middle + 1;    //中位数小于等于key,在右半边序列中查找。
                len = len - half - 1;
            }
        }
        return first;
    }
    ```

~~override~~
