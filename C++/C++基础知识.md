# C++ 基础知识

首先，不要着急让自己明白所有的概念，这些都是需要时间的，你要做的是尽可能在单位时间内消化更多的知识点。

C++你是有语言基础的，消化的时候注意回想总结，明白一些基本的概念，重要的是，心态保持平衡，这点对于现在是极难做到的。

采用分治法的思路解决这个问题。

1. C++的基本语法
2. C++的面向对象基本概念
3. C++的多态实现原理
4. C++的内存管理
5. C++的标准库的基本组成
6. C++实现一个简单的String类

## C++的基本语法

还是采用分治法的策略

1. 基本的数据类型
2. 基本的控制结构
3. 类的定义
4. 类的构造函数，析构函数，拷贝构造函数，复制构造函数的概念
5. 类的封装
6. 类的继承
7. 类的多态

### 基本数据类型

基本的数据类型如下：

    bool, char, int, float, double, void, wchar_t

基本的类型修饰符如下：

    signed, unsigned, short, long

变量作用域

    1. 局部变量
    2. 全局变量
    3. 形式参数

    这里特别的说明一下“形式参数”，函数参数中定义的变量都是“形式参数”，通常形式参数都是值拷贝，C++引入一个引用拷贝，引用拷贝使得形式参数可以变成“值-结构”参数，有点类似指针的作用，但是，不同与指针的是，指针的“形式参数”也是值拷贝。

为了理解作用域的概念，这里需要简单的说下，C++的内存分配基本知识：

    1. 栈区---有编译器自动分配释放，局部变量，形式化参数等值的存储区域
    2. 堆去---一般由程序员分配释放，主要使用new或者malloc，realloc等进行内存申请，如果程序员不释放，会在程序结束的时候，由OS回收
    3. 全局区（静态区）--- 全局变量和静态变量存放的地方，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后，有系统回收
    4. 文字常量区 --- 常量和常量字符串就是放在这里。程序结束后由系统释放
    5. 程序代码区 --- 存放函数体的二进制代码

~~new, malloc, realloc 的区别~~

~~内存泄漏是个什么概念？~~

特殊的作用域

    C语言有个很特别的关键字“static”，这个关键字可以修饰变量类型，使得变量变成一个静态变量，这个修饰符还可以修饰函数，使得函数变成静态函数，某种意义上函数也是一个变量，嗯，这么说函数更像一个指针值，函数名就是可以表示这个函数的指针值。

    所谓的静态类型，可以理解成一个环境变量，全局变量其实可以理解成全局的环境变量。

    静态的局部变量就相当于局部的环境变量，理论上来说，局部变量是存在在堆栈中，随着局部状态的退出而消失，静态的局部变量不同，静态局部变量是存放在全局静态区，是不会随局部状态的退出而回收的。

    静态变量还有一个很重要的特性，限定了变量的作用范围，静态的局部变量先定了变量的范围为局部变量的使用范围，静态的全局变量，限定了变量自当前声明处起至文件末尾有效，不可被extern执行外部引用。

    静态成员函数也有此特性，静态成员函数是属于类的属性，不是对象的属性。同理，还有静态成员变量，静态成员变量也是类的属性，不是对象的属性。所谓的类的属性，就是说所有对象共享这个属性。

const修饰符

    const修饰一个变量的时候，这个变量我们称之为常量变量，这是const的一种简单用法。

    其实，const是限定某个变的东西使得不可变，具体的有如下一些用法：
    
        1. 限定变量，使得变量变成常量
        2. 限定引用类型的形式参数，使得引用类型的形式参数不可修改
        3. 限定成员函数，使得成员函数中不能修改对象的成员变量

const 和 指针 的复合修饰

    指针变量这里以 "int * a" 做为例子进行解释。

    指针变量有两个特性，一个特性是修改指针本身的值，一个是修改指针所指向地址的值。

    基于指针的特性，const对指针类型的变量，也有两种修饰方式：

        1. const int * a; // 此种情况，说明指针所指向的地址的值不可修改
        2. int const * a; // 此种情况和1相同，只是语法问题
        3. int * const a; // 此种情况，说明指针本身的值不可修改
        4. const int * const a; // 此种情况，说明指针的和指针所指向的地址值都是不可修改的

### 基本的控制语句

嗯，C++的控制语句和C语言的基本是一致的，也就是 if...else... while... for... 之类的

### 类的定义

类从整体上来说，C++类的主要分成三个部分：类名，成员函数，成员变量

C++为了保证封装性对成员函数和成员变量使用了修饰符：public，protected，private

C++的继承也有这三个特殊的修饰符，这里，我们需要对这三个特殊的修饰符进行简要的说明

第一：private, public, protected 访问标号的访问范围。

private：只能由1.该类中的函数、2.其友元函数访问。
不能被任何其他访问，该类的对象也不能访问。

protected：可以被1.该类中的函数、2.子类的函数、以及3.其友元函数访问。
但不能被该类的对象访问。

public：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问，也可以由4.该类的对象访问。

注：友元函数包括3种：设为友元的普通的非成员函数；设为友元的其他类的成员函数；设为友元类中的所有成员函数。

第二：类的继承后方法属性变化。
private 属性不能够被继承。
使用private继承，父类的protected和public属性在子类中变为private;
使用protected继承，父类的protected和public属性在子类中变为protected;
使用public继承，父类中的protected和public属性不发生改变;

如下所示：
                    public          protected:      private:
public继承          public          protected       不可用
protected继承       protected       protected       不可用
private继承         private         private         不可用

protected继承和private继承能降低访问权限。

这里，首先这里只是说子类不能直接访问父类的私有成员，并不是说，子类不能使用父类的私有成员，其实父类的私有成员还是被创建的。

构造函数的初始化列表的使用注意事项:

    1、成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了。这点在EffectiveC++中有详细介绍。
    2、如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。
    3、注意：类成员在定义时，是不能初始化的
    4、注意：类中const成员常量必须在构造函数初始化列表中初始化。
    5、注意：类中static成员变量，必须在类外初始化。
    6、静态变量进行初始化顺序是基类的静态变量先初始化，然后是它的派生类。直到所有的静态变量都被初始化。这里需要注意全局变量和静态变量的初始化是不分次序的。这也不难理解，其实静态变量和全局变量都被放在公共内存区。可以把静态变量理解为带有“作用域”的全局变量。在一切初始化工作结束后，main函数会被调用，如果某个类的构造函数被执行，那么首先基类的成员变量会被初始化。  

类的继承构造函数的调用顺序

    记忆原则，从“根”出发，一层一层到要构造的类；
    析构函数则恰好相反
    C++构造函数按下列顺序被调用：
    (1)任何虚拟基类的构造函数按照它们被继承的顺序构造；
    (2)任何非虚拟基类的构造函数按照它们被继承的顺序构造；
    (3)任何成员对象的构造函数按照它们声明的顺序调用； // 很重要，这点也很好理解，程序就是按照顺序去进行内存填充的
    (4)类自己的构造函数。

C++中的虚拟继承

    主要是针对如下情况：
          A 
        /   \ 
        B    C 
        \   / 
          D 
    类D在实例化的时候，存储区只会有一个类A，不会存在二义性，其中类B，类C都是虚拟继承类A，类A被称为虚拟基类

~~友元概念~~

### 类的构造函数，析构函数，拷贝构造函数，复制构造函数的概念

首先明白构造函数的意义：程序代码一般都会经历两个阶段，第一个阶段初始化阶段，这一阶段可以理解成世界的开始状态，第二个阶段运转阶段，这一阶段就是整个世界在开始状态的情况下开始运转。

对于第一阶段其实是程序员比较容易忽视的，因为大家大部分的精力都是放在第二阶段世界应该如何运转，更专业的术语是我们更多关注的是算法的实现。

C++为了更好的提醒程序员，每个世界都应该有个初始化的过程，所以，使用了构造函数这个概念，用来显示的控制世界的初始化的过程。

C++存在四大构造函数：

    1. 默认构造函数（无参构造函数）
    2. 有参构造函数
    3. 拷贝构造函数
    4. 赋值构造函数

当类没有定义构造函数的时候，C++会为类生成一个默认构造函数，默认构造函数是无参形式的，默认构造函数会根据成员变量的数据类型设置默认的初始化值，如果用户主动定义无参构造函数，那么默认构造函数的行为将会被隐藏。

有参构造函数主要是应对某些类实例化对象的时候需要引入一些配置参数，这时候，有参构造函数就能将这些配置参数设置成形式化参数。

拷贝构造函数主要应对如何从另一个同类型的对象拷贝一份新的对象，这里需要注意一点，C++的拷贝分深拷贝和浅拷贝两种，这两种都有对应的用法。

    拷贝构造函数必须以引用的方式传递参数。这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。

赋值构造函数功能和拷贝构造函数类似，但是这里有着本质的区别：

    1. 赋值构造函数其实是运算符重载，重载的是赋值运算符
    2. 赋值构造函数应该不能叫构造函数，理论上构造函数是要支持初始化列表这种形式的，赋值构造函数只能在函数体中对类的成员进行初始化
    3. 为了满足赋值的连续性，赋值构造函数通常需要返回类对象的自引用
    4. 如果一个对象没有构造过，那么及时在定义的时候使用赋值运算符，其实本质编译器会调用拷贝构造函数，这也说明，赋值构造函数只是针对已经构造过的对象才会起作用

为了更好的理解这段内容，这里引入一个String类的简单实现：

    ```c++
    #include <string.h>

    using namespace std;

    class String {
    public:
        String();
        String(char * sch);
        String(const String & oth);
        String & operator = (const String & oth);
        ~String();

        void SetString(char * sch);

    private:
        void NewString(int size);
        void ReleaseString();

    private:
        char * m_ch; // 存储实际的字符串
        int m_len;   // 存储当前字符串的长度，此长度不含有'\0'
    };

    String::String() : m_len(-1), m_ch(nullptr) {
    }

    String::String(char *sch) : m_len(-1), m_ch(nullptr) {
        this->SetString(sch);
    }

    String::String(const String & oth) : m_len(-1), m_ch(nullptr) {
        this->SetString(oth.m_ch);
    }

    String & String::operator=(const String &oth) {
        if (this == &oth) {
            return *this;
        }
        this->SetString(oth.m_ch);
        return *this;
    }

    String::~String() {
        this->ReleaseString();
    }

    // 引入一个字符串
    void String::SetString(char * sch) {
        this->ReleaseString();
        if (this->sch != nullptr) {
            this->NewString(strlen(sch));
            strcpy(this->m_ch, sch);
        }
    }

    // 引入辅助函数，创建一片字符串存储空间
    void NewString(int size) {
        this->m_len = size;
        this->m_ch = new char[size+1];
        this->m_ch[size] = '\0';
    }

    // 引入辅助函数，释放原有的内存
    void String::ReleaseString() {
        if (this->m_ch != nullptr) {
            delete [] this->m_ch;
            this->m_ch = nullptr;
        }

        this->m_len = -1;
    }
    ```

这段代码其实蛮困难的，考虑的点其实比较多，嗯，这段代码要是能够在任何时段手写出来，对C++的基本知识点其实都考量的差不多了。

~~构造函数中的this指针~~

~~深拷贝和浅拷贝的理解~~

~~智能指针的实现（这里使用了一个浅拷贝的概念）~~

~~右值，移动语义~~
