# 反射模式实现工厂模式



下面是 `newobj.h ` 文件的实现：

```c++
#ifndef NEWOBJ_H
#define NEWOBJ_H

#include <string>
#include <map>

class NewObj
{
public:
    virtual ~NewObj(){}
    virtual void* operator()() = 0;
};

template <class T>
class NewObjWrapper : public NewObj
{
public:
    NewObjWrapper(const std::string& key)
    {
        extern std::map<std::string, NewObj*>* g_newobjs;
        extern void newObjSystemInit();
        newObjSystemInit();
        g_newobjs->insert(std::pair<std::string, NewObj*>(key, this));
    }

    void* operator()() override
    {
        return new T();
    }
};

extern void* NewObjApply(const std::string& name);

template <class T>
class NewObjInstance
{
public:
    template <class... Args>
    T* operator()(Args... args)
    {
        return new T(std::forward<Args>(args)...);
    }
};

#define MACRO_ARG_COUNT_(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, N, ...) N
#define MACRO_ARG_COUNT(...) MACRO_ARG_COUNT_(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)

#define COMBINEKEY_IMPL(a, b) a##b
#define COMBINEKEY(a, b)      COMBINEKEY_IMPL(a, b)

#define REGISTER_IMPL_2(CLS, KEY, ID) NewObjWrapper<CLS> g_newobj_##ID(KEY)
#define REGISTER_IMPL_1(CLS, KEY, ID) REGISTER_IMPL_2(CLS, KEY, ID)
#define REGISTER_2(CLS, KEY)          REGISTER_IMPL_1(CLS, KEY, COMBINEKEY(CLS, __COUNTER__))
#define REGISTER_1(CLS)               REGISTER_2(CLS, #CLS)

#define NEWOBJ_2(KEY, CLS) (CLS*)NewObjApply(KEY)
#define NEWOBJ_1(KEY)      NEWOBJ_2(KEY, void)

#define REGISTER(...)       COMBINEKEY(REGISTER_, MACRO_ARG_COUNT(__VA_ARGS__))(__VA_ARGS__)
#define NEWOBJ(...)         COMBINEKEY(NEWOBJ_, MACRO_ARG_COUNT(__VA_ARGS__))(__VA_ARGS__)
#define NEWOBJINS(CLS, ...) NewObjInstance<CLS>()(__VA_ARGS__)

#endif // NEWOBJ_H

```



下面是 `newobj.cpp ` 文件的实现：

```c++
#include "newobj.h"

#include <map>
#include <string>

std::map<std::string, NewObj*>* g_newobjs;

void newObjSystemInit()
{
    static int isInit = 0;

    if (isInit) return;
    isInit = 1;

    g_newobjs = new std::map<std::string, NewObj*>();
}

static class NewObjSystemRelease
{
public:
    ~NewObjSystemRelease()
    {
        delete g_newobjs;
    }
} newObjSystemRelease;

void* NewObjApply(const std::string& name)
{
    if (g_newobjs->find(name) == g_newobjs->end()) return NULL;
    return (*(g_newobjs->find(name)->second))();
}

```



我们如何使用这个反射呢，我们只要在我们定义的类中，使用宏 `PUTCLS` 进行类注册，如过要生成一个对象，我们使用 `NEWOBJ` 进行对象的生成。

注意，我们的类需要实现无参构造函数。



## 分析1



以前，我认为，C++ 中的模板和宏是如此复杂，如此难懂，如此不好用的东西，我写代码就不用就是了，简单的说，就是忽视他们的存在。

其实，这种想法是错误的，因为，我错误的低估了模板和宏的作用。



C++ 支持运行时的多态，多态这个概念就是说一个对象，对某个虚函数的表达依赖于具体的对象生成所使用的实现类。这里，其实就有一个非常重要的语言设计------虚函数表。

如果你去面试 C++ ，多多少少别人都会问一下，什么是虚函数表，以及虚函数表的实现方式？如果面试官更狠一点，为什么要有虚函数表？是不是觉得面试官是个傻逼，问这种八百年你不用知道的东西，你只要会用就行了。



虚函数表这种设计其实是一种设计思想：表查询设计。



表查询设计的理念就是 `表注册--查表应用` 。所谓的表注册，就是你要写入一个 `key/value` 对，然后在某个时刻，你能通过 `key` 找到对应的 `value` ，如果 `value` 是一个可调用对象，那么你就可以调用它，从而达到类似回掉函数一样的功能。



虚函数表其实就是实现了这样一种功能，与其说你要知道虚函数表的实现，你还不如知道为什么要有虚函数表。有了这个功能以后，我们就可以面向接口编程，简单的说，我们写了一些接口原型，但是，我们并没有实现它，具体的实现我们放到子类中，子类对象在实例化的时候，就往虚函数表中注册了这个实例类的接口实现函数，从而，当基类对象调用接口的时候，我们能够通过虚函数表，找到具体的子类实现方法，从而实现了运行时的多态。



虚函数表的实现也很简单，我们只要在我们对象的头部，放置一个虚函数表指针，该指针指向一个虚函数表，这个虚函数表就是子类实现的一种表，表的 `key` 就是对应的接口名，表的 `value` 就是对应的实现，如果子类实现了某个接口，那么对应的 `value` 替换成子类的实现方法的地址即可。



从这个实现，我们也可以看出，C++ 做了两件事情：1. C++ 内置了一个表查询功能，2. 该表是一个一级表查询。什么意思呢？简单的说，就是 C++ 天然支持了一级表查询，凡是只需要一级表查询的功能，你都可以使用多态进行实现，更一般的是，C++ 的表查询是一种受限的表查询。



举个例子，某个对象，有两种属性，一个是 `属性a` ， 一个是 `属性b` ，当对象同时满足 `属性a` 和 `属性b` 的时候执行一个方法，同时不满足 `属性a` 和 `属性b` 的时候执行另一个方法。看到没有，这里我们就需要手动的进行组合。不能单纯的依赖 C++ 的多态。



但是，多态从某种意义上使得代码具有更好的扩展性，比如，你发现了一个新类，这个类也具有你抽象的方法的公有接口，那么你就可以扩充你的对象模型了。该对象模型对于上层应用是透明的。这也体现了一定的好的维护性。



现在说下问题，上述的表述说明了，组合可能会存在严重扩充，我们只能做有限的枚举。且，如果子类爆炸加上组合扩充，那么整个类体系将会是灾难性的。



##  分析2



代换模型--这是一个基本的计算模型，C++ 中的宏和模板就是一个典型的代换模型，那么什么是代换模型？

如果 A 可以代换成 B，那么所有的 A 都用 B 代换。

宏是典型的字符串代换，宏自定义了一些内置的宏变量，比如 `__COUNTER__` 。

模板是个基于类型进行代换的模式。

虽然只有两句话，但是，这里具有更多的复杂性，原因是代换具有传递性，更有甚者，模板代换具有自反性。由于代换具有传递性导致代换可能产生扩散反应，扩散反应就是当我修改了某个元素，那么这个修改会传导到整个系统，典型的例子，比如 C 语言中的全局变量，如果修改了全局变量的类型，那么整个系统凡是使用到了这个全局变量的对应的类型就需要调整。

扩散反应优缺点是共存的，有时候我们需要限制扩散反应，有时候我们需要利用扩散反应提高软件的灵活性，比如说，C 语言的编译器，如果 C 语言改变了某些编译行为，那么可能导致原有的代码无法编译成我们期望的软件功能，这就是扩散反应的缺点，但是，如果我们提供兼容性的修改编译行为，那么原有的编译可以保持原有的行为，同时，编译器具有了新的行为，这就是扩散反应的优点。

从这个描述可以看出，控制扩散反应的一个方法保持兼容性设计。但是，如果保持兼容性？我们怎么知道未来可能会出现什么新的情况，这些都依赖于程序员本身的经验以及对软件设计方法的理解。

这里提一下，面向对象提供了一些归纳好的“设计模型”，这些模式可以作为参考，不过，我发现在 C ++ 中其实并不好用，主要的原因是 C++ 的内存管理比较复杂，如果想使用特定的模型，我们往往需要借助智能指针，对于指针的描述，我们后面会专门添加一节进行分析。



扩散反应是我在编程中发现的一个规律，后来我发现这个反应在很多地方都有这个现象，扩散反应的产生本身是因为传导性质导致的。如果某个事物具有传导性质，那么扩散反应就会发生。所以，不要害怕扩散反应，扩散反应是自然的一种状态，控制它，把握它，更好的利用它。



现在，我们明白，虽然宏和模板只是基于代换模型，但是，他的复杂度依然会随着代码的量级，达到不可控的状态，所以，我们常说，禁止使用宏，禁止使用模板等等。但是，但是，但是，如果你封掉了一扇窗户，那么这扇窗户外的世界你就看不到了。少用，慎用，学会一定程度的控制，才是对宏和模板的正确的态度。











































