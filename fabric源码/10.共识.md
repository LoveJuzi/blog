# 共识

共识算法是区块链的一个标志，所以了解共识算法，是理解区块链的一个必要部分。

## raftetcd

这里我们只关心Raft的共识算法，因为这个算法的灵活性更好。

Raft共识本质是基于etcd算法开发的一种共识算法，etcd算法其实是一个分布式网络的一致性算法，zookeeper的实现也是使用了这个算法。

raftetcd算法，这里主要是有两个阶段：

    1. Leader的选举阶段
    2. 日志的复制阶段

首先，分布式算法也没有办法脱离计算机的基本结构，计算机为了保持一定的顺序，通常是把共享资源交付一个程序去控制。分布式一致性算法，也脱离不了这个限制，不过，这里采用的方式有所更改，目的是为了适应当某台机器故障的时候应该如何处理。

其次，这种网络间的通信往往采用时间这个维度去控制流程，通常的一个办法是超时机制，嗯，这个超时时间在这里不能太长，否则会影响到性能。

最后，为了保证数据的完整性，这种分布式网络会采用日志的形式，将数据设计成一个entry，然后为这个写入设置一个提交状态，然后转发。

嗯，这里还有一个问题，raftetcd算法，是要保证所有的机器都要两两互联，嗯，这个要求有点过份，因为随着集群的扩大，这种一致性保持就变得不那么容易扩展。嗯，所以，这里我的理解是，我们能容忍多少台机器同时宕机，比如我们最多能容忍2台机器宕机，那么，按照算法的要求，我们至少需要5台机器，算法的要求是必须要满足大多数机器的请求。

嗯，另外这里还有一个比较严重的问题，就是这个集群支持多少个客户端？嗯，这个问题后面需要看一些文章和源码来获得答案。

这里，简单的介绍一下raftetcd的过程：

1. 首先，启动5台机器，每台机器一开始的状态是follower。
2. 然后，5台机器，同时启动的一个随机时间，等待超时，这个超时我们定义为选举超时，这个时间大概是150ms到300ms，这个时间不能太短，否则可能会导致有效请求的响应时间缩短（比如正常处理Leader消息），这个时间也不能太长，否则效率会有问题。
3. 当某台机器A选举超时了，那么机器A会给其他所有机器发送投票请求，如果其他机器收到了这个消息，且自己还没有投票，那么他们会给机器A投票
4. 机器A计算票的数量，如果数量过一半，那么机器A当选Leader
5. 当机器A当选Leader后，会发送一个Entry消息，告知集群中其他机器，我们现在的Entry起点，其他机器也会反馈这条消息。嗯，这里是采用心跳超时消息进行发送
6. 此时集群中所有机器都可以接受客户端的请求，当客户端发送给集群内容的时候，该内容会被转发给Leader
7. Leader接受到新内容的时候，会尝试把这个内容群发给集群中其他机器，其他机器会尝试写一下，如果写成功，那么其他机器会给Leader返回成功写入的消息
8. Leader会统计写入成功的次数，如果过半，那么Leader会告诉客户端该内容写入成功，且Leader会将内容设置成commit的状态，然后心跳超时将这个内容群发给集群其他机器，其他机器也会写入
9. 至此，集群中的所有机器都达成了一致了

嗯，算法过程还算简单，如果说复杂，复杂在消息的处理流是基于时间的，而不是基于事件的，嗯，超时也应该算一个事件，不过这里用的是时间。

从这里也可以看出，计算机的复杂性，其实和现实社会也有一定的想通性。

```golang
// Possible values for StateType.
const (
	StateFollower StateType = iota
	StateCandidate
	StateLeader
	StatePreCandidate
	numStates
)
```

这个是raft源码中定义的四种状态，嗯，我看的博客都没有介绍过StatePreCandidate这种状态

我从日志看到一个单词“term”，不知道这个词是干什么用的