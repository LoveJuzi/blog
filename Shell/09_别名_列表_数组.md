# 别名 列表 数组

## 简要说明

本文并不是要说明一个系统的概念，而是说明一些语言的其他优势。

## 别名

别名顾名思义就是给某个命令起一个其他的名字，或者某个过程起一个其他的名字，或者其他，最常见的一个别名就是“ll”，这个命令其实不是一个系统命令，它是“ls -l”的一个别名。

### 别名定义

alias

### 消除别名

unalias

## 列表

列表就是多组命令执行，列表有两大类，一类是与列表，一类是或列表。

列表和管道最大的不同点是，类表中命令都是各自独立的输入输出，管道中的命令输出都是下一个命令的输入。

与列表的执行规则：前面的指令若执行错误，那么后面的指令就不执行了。

或列表的执行规则：前面的指令若执行正确，那么后面的指令就不执行了。

列表状态返回值也是真和假，所以可以作为分支判定条件。

这里举一个例子，我们知道“du -sh *”可以获取本地文件夹下所有文件的大小，现在的问题，如果按照文件的大小逆向排序，查找占用空间最大的三个文件。

解：

  ```sh
  du -sh * >/tmp/1 && du -s * >/tmp/2 && paste /tmp/1 /tmp/2 | sort -k3 -rn | cut -f1,2 | sed -n '1,3p' ; rm -rf /tmp/2 ; rm -rf /tmp/1
  ```

解释：

  1. 这里我们使用了与列表和分句。
  2. 之所以使用与列表，是因为我们有多个输入和输出端，这点，无法单纯使用管道解决。

## 数组

Shell的数组和普通的数组的概念不太一样，但是，你依然可以把它当作数组看待。理解数组的概念以后，整个的Shell基本操作就算完成了，剩下的就是管道和进程的概念。

Shell利用数组的概念还可以实现一些基本的数据结构，比如栈等线性数据结构。对于类似树这种数据结构，Shell并没有很好的实现方式，主要的原因是，Shell通常处理的都是线性结构，但凡涉及到树，都是通过指令完成的，比如目录检索这种功能，简言之，当你需要这种功能的时候，你可以使用C语言或者其他脚本语言进行开发，生成指令，然后使用Shell进行应用。

### 定义

1. Shell的数组只能是一维的。
2. Shell变量的默认状态就是一个只有一个元素的一维数组。
3. 圆括号结构可以初始化数组。
4. 数组是可以隔断进行赋值的，但是底层的物理空间是连续的。
5. 数组的起始标号是0。
6. @和*是代表所有的数组标号，通过${array[@]}可以获得所有的数组元素，如果加上引号，可以获得所有已经赋值的数组元素。

### 数组连接

```sh
#!/bin/bash

city=(Beijing Nanjing Shanghai)
person=(Cai [5]=Wu Tang)

declare -a combine

combine=(${city[@]} ${person[@]})
echo "for打印的结果1======>"
for v in ${combine[@]}; do
  echo $v
done
echo "while打印的结果1======>"
count=${#combine[@]}
index=0
while [ $index -lt $count ]; do
  echo ${combine[$index]}
  ((index++))
done

unset combine
combine[0]=${city[@]}
combine[1]=${person[@]}
echo "for打印的结果2======>"
for v in ${combine[@]}; do
  echo $v
done
echo "while打印的结果2======>"
count=${#combine[@]}
index=0
while [ $index -lt $count ]; do
  echo ${combine[$index]}
  ((index++))
done
```

输出结果：

![12.png](./img/12.png)

解释：

  1. 两种连接方式都行，但是会有细微的差别。
  2. 另外，不论那种方式，本来不连续的在连接后，都变成连续的，这个给数组的操作提供了某种可能。
  3. 数组的操作相比较其他语言并不是一个高效的操作，但是数组的操作给Shell带来了一定的灵活性。

### 栈

```sh
#!/bin/bash

MAXTOP=50

TOP=0
TEMP=
GTEMP=
declare -a STACK

get() {
  GTEMP=
  if [ $1 -lt 0 ]; then
    return
  fi
  GTEMP=${STACK[$1]}
  return
}

push() {
  if [ -z $1 ]; then
    return
  fi

  until [ $# -eq 0 ]; do
    STACK[$TOP]=$1
    let TOP=TOP+1
    shift
  done
  return
}

pop() {
  TEMP=

  if [ "$TOP" -eq 0 ]; then
    return
  fi

  let TOP=TOP-1
  TEMP=${STACK[$TOP]}
  unset STACK[$TOP]
  return
}

status() {
  echo "==================="
  echo "=======STACK======="
  for v in ${STACK[@]}; do
    echo $v
  done
  echo
  echo "Stack Pointer=$TOP"
  echo "Just popped \"$TEMP\" off the stack"
  echo "==================="
  echo
}
```
