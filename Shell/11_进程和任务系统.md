# 进程和任务系统

## 简要说明

进程不能说是系统，进程就是一个可执行的基本单位，任务指的是为了完成特定功能的一组进程的集合。

不用特别了解这些概念，因为Shell将这些概念隐藏了。

## 圆括号结构

圆括号结构就是一个开启子Shell的功能。

这里有一个算法题，如何开10个进程。这个算法的一个用处就是------生产消费者模型。

解：

  ```sh
  #!/bin/bash

  MAXN=10
  N=

  init_N() {
    N=$MAXN
  }

  # 回收闲置进程
  recall_N() {
    N=0
    pfs=`ls /tmp/process_* 2>/dev/null`
    if [ -z "$pfs" ]; then
      sleep 1 # 如果没有闲置进程，那么需要等待1s
      return
    fi

    echo "$pfs" | xargs rm -rf
    N=`echo "$pfs" | wc -l`
    test $N -gt $MAXN && N=$MAXN

    echo "============>回收进程数$N"

    return
  }

  init_N
  i=0
  while [ $i -lt 100 ]; do  # 100个任务
    if [ $N -eq 0 ]; then
      recall_N
      continue
    fi

    ((i++)) # [1...100]
    (
      random_time=$((RANDOM%5+1))
      echo "======>消费$i开始($random_time)"
      sleep $random_time # 执行任务
      echo "============>消费$i结束($random_time)"
      echo "" >"/tmp/process_$!"
    ) &
    let N=$N-1
  done

  wait
  recall_N
  ```

解释：

  1. 这个算法的一个主要问题是，如何知道某个进程运行结束了？本算法假设进程不会异常结束，这样在临时文件夹下就会生成一个文件，这个文件标志这个进程运行结束了。
  2. 另一个问题是，如何控制资源数。本算法使用了一个简单的资源回收算法，定时检查。
  3. 最后一个问题是，为什么进程控制这么困难？主要的一个原因是进程间是相互隔离的，所有的变量都不是共享的，子进程只是继承了父进程的变量的副本。而文件读写各个进程间又不具有读写锁。这样设计有坏处，当然也有好处，好处就是进程运行的独立性。
  4. 如果遇到这种类似的算法性的任务，最好还是采用线程的概念，当然，目前来说Shell还不支持线程级别的控制。
