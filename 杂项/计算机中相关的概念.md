# 计算机中相关的概念

## 网络方面

### IP，子网掩码，网关

[一文搞懂网络知识，IP、子网掩码、网关、DNS、端口号](https://zhuanlan.zhihu.com/p/65226634)

DNS：域名系统(Domain Name System)。在 Internet 上，域名与 IP 地址之间是一 一对应的，域名虽然便于人们记忆，但机器之间只能互相识别 IP 地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS 服务器就是进行域名解析的服务器 。

域名解析的过程：（没有问过，暂时不做调研）

IP：一种虚拟的地址，用来屏蔽机器的物理地址（MAC地址），局域网中，每台机器的IP地址都是不同的。

IP地址的构成是：主机号和网络号

子网掩码：
    1. 子网掩码不能单独
    2. 子网掩码和IP需要一起使用，可以这样理解：子网掩码是IP的一个属性
    3. 子网掩码的左边都是1，表示网络位，右边都是0，表示主机位，子网掩码的位数和IP位数相同
    4. 子网掩码和IP做与运算就能直接获得网络号
    5. 子网掩码取反，然后和IP做与运算就能直接获得主机号

### 端口

### ICMP 协议

[参考地址](https://www.cnblogs.com/xiaolincoding/p/12571184.html)

ICMP 全称是 Internet Control Message Protocol，也就是互联网控制报文协议。

网络包在复杂的网络传输环境里，常常会遇到各种问题，当遇到问题的时候，总不能死的不明不白，所以需要传出消息，报告遇到了什么问题，这样才可以调整传输策略，以此来控制整个局面。

主要功能：
    1. 确认 IP 包是否成功送达目标地址
    2. 报告发送过程中 IP 包被废弃的原因和改善网络设置等

ICMP报文是封装在IP包内。

ICMP报文有多种类型，主要分成两大类：
    1. 查询报文类型
    2. 差错报文类型

查询报文类型：
    1. 0号报文是回送应答
    2. 8号报文是回送请求

差错报文类型：
    1. 3号报文目标不可达消息
    2. 4号报文原点抑制消息
    3. 5号报文重定向消息
    4. 11号报文超时消息

3号报文目标不可达消息：
    1. 网络不可达（代码0）：路由器表匹配不到接收方的IP的号
    2. 主机不可达（代码1）：路由表中没有目标主机的信息，或者目标主机没有连接到网络
    3. 协议不可达（代码2）：防火墙禁止TCP协议访问
    4. 端口不可达（代码3）：主机未启动对应的端口服务
    5. 需要进行分片但设置了不分片位（代码4）：IP首部分片禁止标志位设置为1，途中路由遇到超过MTU大小的数据包时，会丢弃该报文

4号报文原点抑制消息:
    主要是为了缓和网络拥堵的情况，一般出现在低速网络中，比如广域网，这里IP层也有一个发送缓存队列，如果缓存队列的可用空间为0，那么会报告这个错误

5号报文重定向消息：
    当路由器发现发送端使用了不是最优路径发送数据的时候，会返回这个错误消息

11号报文超时消息：
    IP包有个生存周期的字段TTL，这个字段标识IP包在网络中可跳跃的次数，当TTL归0的时候，报告超时消息

### PING的工作原理

情况分类：
    1. 局域网的情况
    2. 广域网的情况

相关概念：
    1. IP地址
    2. MAC地址
    3. 请求应答
    4. 广播
    5. 报文，报文格式
    6. ICMP协议
    7. 交换机
    8. 路由器
    9. ARP协议

具体流程：
    1. 源主机构建一个ICMP回送请求消息（也就是8号报文）
       1. 报文中有个序号，没发送一次，序号加1
       2. 报文中还记录发送时间，目的是为了计算RTT（往返时间）
    2. 添加IP首部，IP首部包含源地址，目标地址和协议类型
    3. 添加MAC头，MAC头包含目标MAC和源MAC
       1. 如果本地ARP映射表查找出目标IP地址对应的MAC地址，那么直接使用
       2. 否则，需要广播发送ARP协议查询目标IP地址对应的MAC地址
    4. 目标主机接收到这链路层的包，校验目标MAC地址和本机是否匹配，如果匹配丢弃MAC头
    5. 目标主机IP层校验信息，如果校验成功，丢弃IP首部
    6. 目标主机构建一个ICMP回送响应消息（也就是0号报文）
       1. 报文序号和请求消息序号一致
       2. 报文中记录发送时间

至此，PING的一个简单过程介绍完毕

### ARP攻击

ARP 全称 Address Resolution Protocol 地址解析协议，主要的目的负责将某个IP地址解析成对应的MAC地址

ARP攻击主要是通过伪造IP地址和MAC地址进行欺骗，主要存在于局域网中。

ARP通信数据剧增导致网络中断

### 路由，路由表

### 网络PING不通的可能原因

这个问题主要还是想考ICMP报文差错消息有哪些:
    1. 3号报文目标不可达消息
    2. 4号报文原点抑制消息
    3. 5号报文重定向消息
    4. 11号报文超时消息

回答的时候，主要考虑哪些情况可能导致上面的4种错误即可。

1、防火墙挡住了ping请求

2、ip地址弄错了

3、网线没有接好

4、交换机坏了

5、ping服务被禁止掉了

6、网络配置不对，比如ip、网关、子网掩码

### I/O多路复用

首先，这是一个概念性的问题，面试的时候，需要讲清楚，我觉得就行了。

Linux I/O 模型分类：
    1. 阻塞式I/O
    2. 非阻塞式I/O
    3. I/O复用
    4. 信号驱动式I/O（SIGIO）
    5. 异步I/O

输入操作通常包含两个不同的阶段：
    1. 等待数据准备好
    2. 从内核向进程复制数据

以套接字为例：第一步通常涉及等待数据从网络中到达，当所等待分组到达时，它被复制到内核中的某个缓冲区；第二步就是把数据从内核缓冲区复制到应用进程缓冲区

阻塞式I/O流程：
    1. 系统调用，无数据报准备好，阻塞系统调用
    2. 数据报准备好复制数据报
    3. 复制完成，返回成功指示，用户程序继续处理其他任务

非阻塞式I/O流程：
    1. 系统调用，无数据报准备好，返回EWOULDBLOCK
    2. 重复步骤1，直到数据报准备好复制数据报
    3. 复制完成，返回成功指示，用户程序继续处理其他任务

I/O复用流程：（以select为例介绍）
    1. 系统调用，同时等待多个I/O流，无数据报准备好
    2. 数据报准备好，返回可读条件
    3. 根据可读条件，一次调用读写函数读写对应的I/O流
       1. 数据报准备好复制数据报
       2. 复制完成，返回成功指示

### select，poll，epoll的区别

[参考网址1](https://www.cnblogs.com/aspirant/p/9166944.html)
[参考网址2](https://www.cnblogs.com/Anker/p/3263780.html)

首先，这三个函数的目的都是为了实现I/O复用。

所谓的I/O复用，就是在某个时刻点同时等待多个I/O的可读/可写条件，如果在某个时刻点，某些I/O允许读/写，那么返回那些可读/可写的条件给用户应用程序，然后用户应用程序根据可读/可写的条件针对特定的文件I/O调用对应的读写函数，将数据报复制到用户空间。

时间复杂度方面：
    select，poll都是O(n)，而epoll是O(1)，原因是，不论是select和poll都只能感知有I/O事件发生了，但是，不知道具体是哪几个流，只能无差别轮询所有流，找出可读/可写的流，所以如果同时等待的流过多，那么轮询时间也会变长。epoll采用了另一种方式，epoll采用了事件通知的方式，当有I/O事件发生了，那么会直接通知我们具体那个流发生了I/O事件，然后只要针对这个I/O流进行处理就可以了，epoll本质上应该是一种事件驱动的方式工作的

select：
    1. 单个进程可监视的fd数量被限制
    2. 当有I/O事件发生的时候，需要轮询查找具体是哪个fd发生了I/O事件
    3. 需要为何一个存放大量fd的数据结构，这个会增加用户空间和内核空间在传递该结构时复制开销变大

poll:
    1. 没有最大并发连接限制
    2. 当有I/O事件发生的时候，需要轮询查找具体是哪个fd发生了I/O事件
    3. 需要为何一个存放大量fd的数据结构，这个会增加用户空间和内核空间在传递该结构时复制开销变大

epoll:
    1. 没有最大并发连接限制
    2. 效率提升，没有采用轮询的方式，不会因fd数量的增加，导致性能的下降。系统会直接返回活跃fd给用户程序。
    3. 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递，

epoll的API：

    ```c
    int epoll_create(int size);
    int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
    int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
    ```

epoll的操作流程：
    1. 使用epoll_create创建一个epoll句柄，参数size告知内核监听的数目一共是多大。
    2. 使用epoll_ctl注册要监听的事件类型，参数epfd是epoll_create返回的epoll句柄，参数op表示动作（ADD，MOD，DEL），参数fd表示需要监听的句柄，参数event表示事件的内容，该结构有两个成员，第一个是事件类型，第二个是用户数据数据，比如含有fd的值等等。
    3. 使用epoll_wait等待事件发生，参数events就是内核告知用户程序当前时刻的可读写条件，参数maxevents不能大于创建是的size，参数timeout表示超时时间，在一段时间内，如果没有I/O事件，那么函数返回超时错误。

epoll的工作模式：
    1. LT模式（默认模式）：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。
    2. ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。

ET模式有什么用？
    ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

### 异步I/O工作原理

## 数据库方面

### B+树概念

[参考地址1](https://blog.csdn.net/guanyasu/article/details/53443142)
[参考地址2](https://blog.csdn.net/u013411246/article/details/81088914)

B+树是对B树的一种改进，所以首先需要了解什么是B树。

B树的存在，其实是为了解决当存储的key及对应的卫星数据超过了内存的容量的时候，我们如何使用二分查找的方式查询key？这里，还引入了另一个问题，我们如何保存所有的key？

如果想实现二分查找，那么需要保证元素的顺序是有序的。

由于key的量超过了内存的容量，所以，我们需要使用外存，也就是磁盘，那么这就会引入一个问题，磁盘的读写速度比内存的读写速度慢几个数量级，所以，我们应该尽量的减少磁盘的读写。

B树可以有效解决上面的两个问题。

B树的性质如下：
    1. 每个节点x有下面属性：
       1. x.n当前存储在节点x中的关键字个数
       2. x.n个关键字本身 x.key(1), x.key(2), ... , x.key(x.n)，以非降序存放，使得 x.key(1) <= x.key(2) <= ... <= x.key(x.n)
       3. x.leaf，一个布尔值，如果x是叶结点，则为TRUE
    2. 每个内部节点x还包含x.n+1个指向其孩子的指针x.c(1), x.c(2), ... , x.c(x.n+1)。叶节点没有孩子。
    3. 孩子节点中的key介于父节点中相邻key的区间里面，也就是说: k(1) <= x.key(1) <= k2 <= x.key(2) <= ... <= x.key(x.n) <= k(x.n+1)
    4. 每个叶结点具有相同的深度
    5. 每个节点所包含的关键字个数有个上界和下界。用t表示B树的最小度数，t >= 2
       1. 除了根节点以外的每个内部节点必须至少有t-1个关键字，也就是说，除了根节点，每个内部节点都有t个孩子。如果数非空，根节点至少有个一个关键字。
       2. 每个内部节点至多可包含2t-1个关键字，也就是说，每个内部节点至多可有2t个孩子。当某个内部节点恰好有2t-1个关键字时，称该节点是满的。

通常，当t的值越大，树的高度会越低。

B+树是针对B树的一种改造，B+树具有如下的性质：
    1. 基本定义和B树类似，除了
    2. 内部节点的子树指针和内部关键字的个数相同
    3. 内部节点的子树指针P[i]，指向的关键字属于[K[i], K[i+1])
    4. 为所有的叶子节点增加了一个链指针，方便区间检索
    5. 所有关键字都是在叶子节点中

B+树的特性：
    1. 所有关键字都出现在叶子节点的链表中（稠密索引），且链表中的关键字恰好是有序的
    2. 不可能在叶子节点中命中
    3. 内部节点相当于叶子节点的索引（稀疏索引），叶子节点相当于是存储数据的数据层
    4. 更适合文件索引系统

### 线段树概念

### 事务概念

[参考网址1](https://www.cnblogs.com/takumicx/p/9998844.html)

引入问题：
    1. 执行转账操作，转出成功，但是转入失败，如何恢复
    2. 执行转账操作刚完成系统崩溃，系统重启恢复时丢失崩溃前的转账记录（这个不好理解）
    3. 同时有第三方账户给转入账户转账，造成数据的异常

事务的定义解释：
    1. 数据事务可以包含一个或多个数据库操作，这些操作逻辑上是一个整体
    2. 逻辑操作整体，要么全部执行成功，要么全部不执行
    3. 构成事务的所有操作，要么全都对数据库产生影响，要么全都不产生影响，也就是说，不管事务是否执行成功，数据库总能保持一致性状态
    4. 以上即使在数据库发生故障以及并发事务存在的情况下依然成立

简单一句话，事务的目标是为了实现数据库状态的一致性

事务的ACID特性以及实现原理：
    1. 原子性：事务中的所有操作作为一个整体像原子一样不可分割，要么全部执行成功，要么全部执行失败
    2. 一致性：事务的执行结果必须使得数据库从一个一致性状态到另一个一致性状态。所谓的一致性状态：1. 系统的状态满足数据的完整性约束，2. 系统的状态反应数据库本应描述的现实世界的真是状态
    3. 隔离性：并发执行的事务不会相互影响，其对数据库的影响和它们串行执行时一样
    4. 持久性：事务一旦提交，其对数据的更新就是持久的。任何事务或系统故障都不会导致数据丢失

如何保持一致性是一个关键问题，而对一致性产生破坏主要来自两个方面：
    1. 事务的并发执行
    2. 事务故障或系统故障

数据库是通过并发控制技术和日志恢复技术来处理一致性问题

并发控制技术保证了事务的隔离性，使得数据库的一致性状态不会因为并发执行的操作被破坏

日志恢复技术保证了事务的原子性，使得一致性状态不会因为事务或系统故障被破坏，同时使得已提交的对数据库的修改不会因为系统崩溃而丢失，保证了事务的持久性

并发异常：
    1. 脏写：是指事务回滚了其他事务对数据项的已提交的修改
    2. 丢失更新：是指事务覆盖了其他事务对数据的已提交修改
    3. 脏读：是指一个事务读取了另一个事务未提交的数据
    4. 不可重复读：是指一个事物对同一数据的读取结果前后不一致。脏读和不可重复读的区别是：前者读取的是事务未提交的脏数据，后者读取的是事务以提交的数据
    5. 幻读：是指事务读取某个范围的数据时，因为其他事务的操作，导致前后两次读取的结果不一致。幻读和不可重复读的区别是：不可重复读是针对确定的某一行数据，幻读是针对不确定的多行数据

引入隔离的原因：
    1. 事务具有隔离性，理论上来说事务之间的执行不应该相互影响，其对数据库的影响应该和他们串行执行时一样
    2. 然而完全的隔离性会导致系统并发性能会很低，降低对资源的利用率，因而实际上对隔离性的要求会有所放宽，这也在一定程度造成对数据库一致性要求降低
    3. SQL标准为事务定义了不同的隔离级别，从低到高一次是：
       1. 读未提交
       2. 读已提交
       3. 可重复读
       4. 串行化

事务的隔离性的实现:
    1. 乐观并发控制：对于并发执行可能冲突的操作，假定其不会真的冲突，允许并发执行，直到真正发生冲突时采取解决冲突，比如让事务回滚。
    2. 悲观并发控制：对于并发执行可能冲突的操作，假定其必定会发生冲突，通过让事务等待或者中止的方式，使并行操作串行执行。


### 事务的实现原理

### 分布式事务的概念

### 事务的隔离机制

### 如何提高查询速度

## HTTPS的工作原理

## 集群方面

### 分布式HASH

### 分布式路由

### 分布式锁

### 分布式扩容

## 消息队列

### KAFKA工作原理

### RabbitMQ 与 KAFKA 的区别

## 池子相关的概念

### 池子基本组成元素

### 池子的工作原理

### 如何实现一个线程池

## 多线程

### 详细说下通信的几个手段

### 锁，条件变量，信号量区别

### 协程和线程的区别

### 线程安全是个什么概念

### 去锁的一些办法

## 缓存方面

### 说下redis的数据结构

### 哈希表的具体实现

### zset的具体实现

## 算法方面

### 详细说下LRU算法的实现

[参考网址1](https://blog.csdn.net/youanyyou/article/details/78989956)

最不经常使用算法(LFU):
    使用一个计数器记录条目被访问的频率。通过使用LFU缓存算法，最低访问数的条目首先被移除。

LFU的缺点：
    无法对一个拥有最初最高访问率之后长时间没有被访问的条目缓存负责

LFU的实现：
    需要三张表，一张表记录KV信息，一张表记录K的计数，一张记录对应的计数含有的K的列表

最近最少使用算法(LRU):
    这个缓存算法将最近使用的条目存放到靠近缓存顶部的位置。当一个新条目被访问时，LRU将它放置到缓存的顶部。当缓存达到极限时，较早之前访问的条目将从缓存底部开始被移除。这里会使用到昂贵的算法，而且它需要记录“年龄位”来精确显示条目是何时被访问的。此外，当一个LRU缓存算法删除某个条目后，“年龄位”将随其他条目发生改变。

LRU的实现：


LRU的实现：

## 并发

### 高并发问题
