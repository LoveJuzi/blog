# Go基础

Go语言虽然不是我的主语言，不过Go语言的简洁性还是吸引着我，这里需要对Go语言有个整体性的认识。

对于一门语言，我们需要对我们的学习进行基本的划分，每个划分侧重理解的主题都是不同的

    1. 基本概念
    2. 包，struct, interface
    3. slice，map
    4. go，channel，select
    4. 基本库

## 基本概念

基本概念主要是涉及一门语言的两个板块：

    1. 基本数据类型
    2. 流程控制语句

### 基本数据类型

Go的基本数据类型主要分成四大类：

    1. 布尔型
    2. 数字类型
    3. 字符串类型
    4. 派生类型

#### 布尔型

Go的布尔类型关键字是：bool，主要就两个值：true 和 false

嗯，Go语言是强类型语言，通常不属于同一类的数据类型，是不能进行类型转换的，比如，布尔类型不能强制类型转换成整数类型，因为，整数类型是属于数字类型的

#### 数字类型

数字类型分成两大类：

    1. 整数类型
    2. 浮点数类型

这个分类和C语言的分类有点像，不过，对于Go语言来说，对于类型分的更细致：

整数类型：

    int
    int8
    uint8
    int16
    uint16
    ...
    int64
    uint64

浮点数类型：

    float32
    float64
    complex64
    complex128

其他数字类型：

    byte
    rune
    uintptr

这里重点说下rune和uintptr

rune:

    rune 占用内存是4个字节。rune 的存在是为了计算 string 使用的

    Go语言的string采用的是UTF-8的编码形式，也就是说，string的单纯字节长度不能表示实际的字符串的长度，尤其是对中文

    不过，Go语言的 for 语句可以自然遍历 string 类型的数据，而且是以字符为单位的形式，这时候，接收这个字符的需要使用 rune 类型，传统的 byte 类型就无法满足要求了

uintptr

    这个类型是一个底层的指针类型，我们知道Go语言的指针是不能够做加法运算的，原因是这样可以一定程度保证指针的越界访问问题，但是，Go语言并不是完全屏蔽了这个特性，Go语言引入uintptr，嗯，这里暂时了解一下，毕竟还不是必须要操操作指针

#### 字符串类型

Go语言的字符串采用的是UTF-8的编码形式，嗯，Go语言的字符串是不可修改的，这点和C语言有区别。

嗯，这里引入一个问题，如何翻转一个Go的字符串？

    解决方案是使用rune[]数组，首相将字符保存到rune数组中，然后反转，然后将rune数组变换的字符串即可。

#### 派生类型

派生类型主要有如下分类：

    1. 指针类型（Pointer）
    2. 数组类型
    3. 结构化类型(struct)
    4. Channel 类型
    5. 函数类型
    6. 切片类型
    7. 接口类型（interface）
    8. Map 类型

派生类型每种都有特定的用处，这里暂时不展开说。

## 包

Go语言的包概念是一个比较大的概念。

Go语言里面的包在形式上来说就是一个文件夹，文件夹下面还可以生成一个子包，每个包中都可以有自己的go文件，每个go文件包声明是相同的。

这里有个小问题：

    原则上包文件夹的名字最好和包文件中定义的包名一致，这样在引用包的时候，就无需使用import进行重命名，import会自动的将包文件夹的名字作为包名，从而，我们在使用的时候，能够直接使用包名访问包的方法。

这里引入一个问题，Go语言中有个问题就是如何区别公有成员还是私有成员？

    C++语言中，对于类的成员有三种分类：公有成员，保护成员和私有成员。Go语言对于成员有两种划分：公有成员和私有成员。

    所谓的公有成员就是在其他包中可以被访问的成员，所谓的私有成员就是其他包无法访问的成员。

    Go语言公有成员采用大写字母开头，私有成员采用小写字母开头。

    对于Go语言而言，一个包其实相当于一个类，凡是需要对外的，我们都采用大写字母开头命名，凡是无需对外的，我们采用小写字母开头，这个特点甚至传递到struct中成员的定义。

包引用问题：

    对于自定义的包，需要使用全路径的形式，也就是从根文件开始引用

    其他的，采用库路径的进行引用，默认会有GOPATH和GOROOT路径

## channel

Go语言的channel是一个特色，这里需要对channel进行一定程度的解释，分成两大部分：

    1. channel的基本使用方式
    2. channel的基本实现原理

### channel的基本使用方式

channel根据是否有缓冲区，分成两大类：

    1. 无缓冲区channel
    2. 有缓冲区channel

#### 无缓冲区channel
